#include <Wire.h>
#include <Adafruit_Sensor.h>
#include <Adafruit_BME680.h>
#include <DFRobot_ENS160.h>

// Initialize sensors
Adafruit_BME680 bme680;
DFRobot_ENS160_I2C ens160(&Wire, /*I2CAddr*/ 0x53); // Confirmed working address

// Timing variables
unsigned long previousMillis = 0;
const long interval = 5000; // Read sensors every 5 seconds
bool ens160Found = false; // Global variable to track ENS160 status

void setup() {
  Serial.begin(115200);
  while (!Serial) delay(10);
  
  Serial.println("=== ESP32 Complete Air Quality Monitor ===");
  Serial.println("Initializing BME680 and ENS160-BGLM sensors...\n");
  
  // Initialize I2C
  Wire.begin();
  
  Serial.println("*** SCANNING FOR I2C DEVICES ***");
  delay(1000);
  
  byte error, address;
  int nDevices = 0;
  for(address = 1; address < 127; address++) {
    Wire.beginTransmission(address);
    error = Wire.endTransmission();
    if (error == 0) {
      Serial.print(">>> I2C device found at address 0x");
      if (address < 16) Serial.print("0");
      Serial.println(address, HEX);
      nDevices++;
    }
  }
  if (nDevices == 0) {
    Serial.println(">>> No I2C devices found!");
  } else {
    Serial.println(">>> Total devices found: " + String(nDevices));
  }
  Serial.println("*** I2C SCAN COMPLETE ***\n");
  
  // Check power supply
  Serial.println("Power Check:");
  Serial.println("ESP32 3.3V pin voltage should be ~3.3V");
  Serial.println("If using breadboard, check voltage at sensor VCC pins");
  Serial.println();
  
  // Initialize BME680
  if (!bme680.begin()) {
    Serial.println("ERROR: Could not find BME680 sensor!");
    while (1) delay(10);
  }
  
  // Configure BME680 oversampling and filter settings
  bme680.setTemperatureOversampling(BME680_OS_8X);
  bme680.setHumidityOversampling(BME680_OS_2X);
  bme680.setPressureOversampling(BME680_OS_4X);
  bme680.setIIRFilterSize(BME680_FILTER_SIZE_3);
  bme680.setGasHeater(320, 150); // 320°C for 150ms
  
  Serial.println("✓ BME680 initialized successfully");
  
  // Initialize ENS160 at confirmed address 0x53
  if (ens160.begin() == 0) {
    Serial.println("✅ ENS160 found at 0x53");
    
    // Try to reset and reconfigure
    delay(100);
    ens160.setPWRMode(ENS160_STANDARD_MODE);
    delay(500);
    
    // Set temperature and humidity from BME680 if available
    ens160.setTempAndHum(25.0, 50.0);
    delay(100);
    
    Serial.println("✅ ENS160 initialized - warming up...");
    Serial.println("⏳ Please wait 3-5 minutes for sensor to reach Status 0");
    ens160Found = true;
  } else {
    Serial.println("⚠ WARNING: ENS160 sensor not found at 0x53!");
    Serial.println("Check wiring and I2C scan results above");
    ens160Found = false;
  }
  
  Serial.println("\n=== Sensor Information ===");
  
  // Display BME680 info
  Serial.println("BME680 Capabilities:");
  Serial.println("- Temperature (°C)");
  Serial.println("- Humidity (%)");
  Serial.println("- Pressure (hPa)");
  Serial.println("- Gas Resistance (Ohms)");
  Serial.println("- Approximate Altitude (m)");
  
  // Display ENS160 info
  Serial.println("\nENS160-BGLM Capabilities:");
  Serial.println("- TVOC (ppb)");
  Serial.println("- eCO2 (ppm)");
  Serial.println("- Air Quality Index (1-5)");
  Serial.println("- Temperature/Humidity compensation");
  Serial.println("- Status monitoring");
  
  Serial.println("\n" + String('=', 60));
  Serial.println("Starting measurements...\n");
  
  delay(2000);
}

void loop() {
  unsigned long currentMillis = millis();
  
  if (currentMillis - previousMillis >= interval) {
    previousMillis = currentMillis;
    
    Serial.println("Timestamp: " + String(millis()) + " ms");
    Serial.println(String('─', 50));
    
    // Read BME680 data
    readBME680Data();
    
    // Read ENS160 data only if sensor was found
    if (ens160Found) {
      Serial.println();
      readENS160Data();
    } else {
      Serial.println("\nENS160 sensor not available - check wiring and connections");
    }
    
    Serial.println(String('═', 60));
    Serial.println();
  }
}

void readBME680Data() {
  Serial.println("BME680 Sensor Data:");
  
  if (!bme680.performReading()) {
    Serial.println("ERROR: Failed to perform BME680 reading!");
    return;
  }
  
  // Temperature
  float temperature = bme680.temperature;
  Serial.println("Temperature: " + String(temperature, 2) + " °C (" + String(temperature * 9.0/5.0 + 32, 2) + " °F)");
  
  // Humidity
  float humidity = bme680.humidity;
  Serial.println("Humidity: " + String(humidity, 2) + " %RH");
  
  // Pressure
  float pressure = bme680.pressure / 100.0; // Convert Pa to hPa
  Serial.println("Pressure: " + String(pressure, 2) + " hPa (" + String(pressure * 0.02953, 2) + " inHg)");
  
  // Gas resistance
  float gasResistance = bme680.gas_resistance / 1000.0; // Convert to kOhms
  Serial.println("Gas Resistance: " + String(gasResistance, 2) + " kΩ");
  
  // Calculate approximate altitude (using standard sea level pressure)
  float altitude = 44330.0 * (1.0 - pow((pressure / 1013.25), 0.1903));
  Serial.println("Approx. Altitude: " + String(altitude, 2) + " meters");
  
  // Calculate dew point
  float dewPoint = calculateDewPoint(temperature, humidity);
  Serial.println("Dew Point: " + String(dewPoint, 2) + " °C");
  
  // Calculate heat index (if applicable)
  if (temperature >= 27.0) {
    float heatIndex = calculateHeatIndex(temperature, humidity);
    Serial.println("Heat Index: " + String(heatIndex, 2) + " °C");
  }
  
  // Air quality assessment based on gas resistance
  String airQualityBME = assessAirQualityBME680(gasResistance * 1000); // Convert back to Ohms
  Serial.println("BME680 Air Quality: " + airQualityBME);
}

void readENS160Data() {
  Serial.println("ENS160-BGLM Sensor Data:");
  
  // Update temperature and humidity from BME680 for better accuracy
  if (bme680.temperature > -40 && bme680.temperature < 85 && 
      bme680.humidity > 0 && bme680.humidity < 100) {
    ens160.setTempAndHum(bme680.temperature, bme680.humidity);
    Serial.println("Updated ENS160 with BME680 T&H: " + String(bme680.temperature, 1) + "°C, " + String(bme680.humidity, 1) + "%");
  }
  
  // Get sensor status
  uint8_t status = ens160.getENS160Status();
  Serial.println("ENS160 Status: " + String(status));
  
  if (status == 0) {
    // TVOC (Total Volatile Organic Compounds)
    uint16_t tvoc = ens160.getTVOC();
    Serial.println("TVOC: " + String(tvoc) + " ppb");
    
    // eCO2 (equivalent CO2)
    uint16_t eco2 = ens160.getECO2();
    Serial.println("eCO2: " + String(eco2) + " ppm");
    
    // Air Quality Index (1-5 scale)
    uint8_t aqi = ens160.getAQI();
    Serial.println("AQI: " + String(aqi) + " (" + interpretAQI(aqi) + ")");
    
    // Interpret TVOC levels
    String tvocLevel = interpretTVOC(tvoc);
    Serial.println("TVOC Level: " + tvocLevel);
    
    // Interpret CO2 levels
    String co2Level = interpretCO2(eco2);
    Serial.println("CO2 Level: " + co2Level);
    
  } else if (status == 1) {
    Serial.println("ENS160 in phase 1");
  } else if (status == 2) {
    Serial.println("ENS160 in phase 2");
    Serial.println(" ");
  } else {
    Serial.println("❌ ENS160 error. Status code: " + String(status));
    Serial.println("Try power cycling the ESP32");
  }
}

// Helper function to calculate dew point
float calculateDewPoint(float temp, float humidity) {
  float a = 17.271;
  float b = 237.7;
  float tempDP = (a * temp) / (b + temp) + log(humidity * 0.01);
  return (b * tempDP) / (a - tempDP);
}

// Helper function to calculate heat index
float calculateHeatIndex(float temp, float humidity) {
  float heatIndex = -8.78469475556 +
                   1.61139411 * temp +
                   2.33854883889 * humidity +
                   -0.14611605 * temp * humidity +
                   -0.012308094 * temp * temp +
                   -0.0164248277778 * humidity * humidity +
                   0.002211732 * temp * temp * humidity +
                   0.00072546 * temp * humidity * humidity +
                   -0.000003582 * temp * temp * humidity * humidity;
  return heatIndex;
}

// Helper function to assess air quality based on BME680 gas resistance
String assessAirQualityBME680(float gasResistance) {
  if (gasResistance > 400000) return "Excellent";
  else if (gasResistance > 300000) return "Good";
  else if (gasResistance > 200000) return "Moderate";
  else if (gasResistance > 100000) return "Poor";
  else return "Very Poor";
}

// Helper function to interpret AQI values
String interpretAQI(uint8_t aqi) {
  switch(aqi) {
    case 1: return "Excellent";
    case 2: return "Good";
    case 3: return "Moderate";
    case 4: return "Poor";
    case 5: return "Unhealthy";
    default: return "Unknown";
  }
}

// Helper function to interpret TVOC levels
String interpretTVOC(uint16_t tvoc) {
  if (tvoc <= 65) return "Excellent";
  else if (tvoc <= 220) return "Good";
  else if (tvoc <= 660) return "Moderate";
  else if (tvoc <= 2200) return "Poor";
  else if (tvoc <= 5500) return "Unhealthy";
  else return "Very Unhealthy";
}

// Helper function to interpret CO2 levels
String interpretCO2(uint16_t co2) {
  if (co2 <= 400) return "Excellent";
  else if (co2 <= 600) return "Good";
  else if (co2 <= 800) return "Moderate";
  else if (co2 <= 1000) return "Poor";
  else if (co2 <= 1500) return "Unhealthy";
  else return "Very Unhealthy";
}
